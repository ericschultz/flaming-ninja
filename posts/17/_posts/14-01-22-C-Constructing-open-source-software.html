---
title: "C) Constructing open source software"
alias: /Blogs/EntryId/130/C-Constructing-open-source-software
---
<p><em>This post is the ninth in a series that will explore why businesses should become active participants in open source communities. We&rsquo;ll explore what open source is, the economics of OSS (open source software), who uses it, how to make projects successful, and how to participate in external projects. It will also taken a deep dive into more complex topics such as the commercialization of FOSS, community vs customers, managing inbound IP, licenses, software hygiene, and when NOT to publish a project. <br />
</em></p>
<p><em>Read the previous post: <a href="http://www.outercurve.org/Blogs/EntryId/129/B-How-freeloaders-build-your-community">How freeloaders build your community</a><br />
Start from the beginning: <a href="http://www.outercurve.org/Blogs/EntryId/112/0-Intro-What-is-OSS">Intro.&nbsp; What is it?</a></em></p>
<p>In the section on freeloaders, we discussed that many in a project&rsquo;s community are simply users of the software.&nbsp; Contribution is the lifeblood of a FOSS community, however, and without contributions the community can&rsquo;t grow beyond the initial project founders. &nbsp;So the <span style="text-decoration: underline;">project</span> needs to make it easy to contribute.&nbsp; People don&rsquo;t just show up ready to work.&nbsp; </p>
<p>Potential contributors very likely start as users, even of the fledgling software before it really starts to take shape as the robust solution it could become.&nbsp; &nbsp;From here, they may want to make modifications or document their particular use cases for their own internal selfish consumption.&nbsp; Finally, they may take those changes and contribute them back to the project.&nbsp; This implies three separate onramps that the project needs to build. </p>
<ul>
    <li>A user onramp: making it trivial to get up and running quickly with a new installation.&nbsp; The more that can be done from providing working binaries for common installs, scripting installs, scripting configuration, and documenting the basics the better. &nbsp;Without this, casual users may become frustrated and walk away.&nbsp; </li>
    <li> </li>
    <li>A developer onramp: making it trivial to rebuild the source to a known state.&nbsp; This means the dependencies are known and installed, the construction recipes can be run simply, and the test results report a known state.&nbsp; At this point, a developer can begin to experiment.&nbsp;&nbsp; Without this, knowledgeable developers may walk away feeling their own valuable time has been wasted trying to get to an understood state. </li>
    <li> </li>
    <li>A contributor onramp: making it trivial to understand how to contribute what artifacts, on what channel, using what guidelines.&nbsp;&nbsp; Without this, valuable changes made beyond the project may never get back to enrich the ecosystem. </li>
</ul>
<p>At the heart of this system of onramps is the software construction tool chain.&nbsp; Good software teams, whether developing sophisticated enterprise applications in-house, products for sale, or collaborating on open source software projects on the Web all use a core set of tools and practices unthinkingly. &nbsp; </p>
<p>The centerpiece of the tool chain is the version control environment.&nbsp; At first blush, developers use versioning tools because without them one would never be able to build the complex software solutions we build today (and really over the past several decades.)&nbsp; Without some form of software versioning, we couldn&rsquo;t track experiments, or alternative lines of development for particular situations like a different chipset or screen size, or have two developers trying alternative approaches to a problem. &nbsp; </p>
<p>At this level, software versioning and configuration management tools make it simple to keep source code &ldquo;in sync&rdquo; without complex manual tree-cloning that could easily loose track of all the differences that get introduced during a divergent set of experiments. It always allows a team to know: which source artifacts were assembled into this running software or website. </p>
<h2>Versioning tools bring scalability</h2>
<p>Without such knowledge we could never scale software to more than a couple of users.&nbsp; That is the real reason good developers rigorously use such tool bases.&nbsp; One needs to know what software is executing to know what changes to make, to answer questions about unexpected behaviour, to evolve and bug fix the software, and to grow the software.&nbsp; Software is remarkably dynamic and invariably changes through use as people find issues, bugs, and want to extend the software in new ways.&nbsp; Without software versioning engines software can&rsquo;t grow. &nbsp; </p>
<p>Without such tool support, one could never reliably build a known executable instance of software, whether it&rsquo;s running a website or it&rsquo;s a binary for broad distribution.&nbsp;&nbsp; The only way to know is to rigorously manage the configuration of software versions, and the recipes that turn source files and other artifacts into executable software.&nbsp; Tools like Git, subversion, and Mercurial do this. &nbsp; </p>
<p>This points to the next requirement: the recipes.&nbsp; Whether you&rsquo;re using simple makefiles or an integrated development environment binary representation of the recipe, the options set and the order of libraries, headers, and indeed the order of steps all critically define the working instance of a software executable.&nbsp; Without knowing how the software was constructed one cannot answer questions about its behaviour.&nbsp; </p>
<h2>Scaling Products to Scaling Projects</h2>
<p>That would mean one could never offer support cost effectively.&nbsp; If you had to inspect the binary and determine its source provenance, build structure, and configuration, costs for support would soar (assuming the inspection process was even feasible).&nbsp; If you can&rsquo;t support the software it can&rsquo;t evolve.&nbsp; This is true of in-house applications development, ISV products in wide distribution, mobile apps, and most especially widely collaborative development projects, a.k.a. open source software. </p>
<p>Every artifact that leads to the running executable instance of software needs to be captured and cataloged so that we can reliably rebuild the software to a known state. &nbsp;Without reliably being able to build software to a known state, no one can properly use and enhance it.&nbsp; </p>
<ul>
    <li>It will be impossible to support users if you can&rsquo;t reliably understand how the running software on their systems got there.&nbsp; </li>
    <li> </li>
    <li>It will be difficult to attract developers if getting to a known state takes too much time. </li>
    <li> </li>
    <li>It will be confusing and complex when trying to integrate contributions back into the workflow.&nbsp; </li>
</ul>
<p>If there's ANY FRICTION in these three pipelines the project runs the risk of losing the slim opportunity of an outside developer&rsquo;s attention and time.&nbsp; Without making change repeatable and reliably easy, the project can&rsquo;t grow beyond the few people that know the magic incantation in all its complexity to turn a collection of source and build artifacts into a working executable instance of the software.&nbsp; &nbsp; </p>
<h2>Best Practices are Universal</h2>
<p>Good developers know this.&nbsp; In today&rsquo;s world, where there is a wealth of such configuration management tools available as free and open source software from versioning engines (CVS, svn, Mecurial, Git), to build engines, automated test engines (xUnit, JUnit) to fully integrated development and deployment environments (Eclipse), there is no excuse for not solving the problem of generating known software.&nbsp; The open source world is lucky enough that all the key components are available for free in forge sites such as Github, codeplex.com, SourceForge, Google Code. &nbsp; </p>
<p>Making it easy for other people to &ldquo;make&rdquo; your software to a known starting state will make it easy for them to fix and enhance your software.&nbsp; Making it easy to reliably get to a known state allows people to experiment with it and contribute.&nbsp; It&rsquo;s not enough to make it &ldquo;easy to fork&rdquo;.&nbsp; It needs to be easy to build and test to a known state.&nbsp;&nbsp; These tool platforms are the only way a FOSS community can scale a community of users and developers to the success of the project in the same way that a software product team could scale development and support to the success of the product. &nbsp; </p>
<p>This is how developers on an OSS project can get more developers involved.&nbsp; Make it easy to contribute by making the software easy to configure, build, and test to a known state.&nbsp; The more time you save outside developers that might be interested in contributing, the more time they have to work on the contribution they want to make, rather than losing time and possibly interest in trying to get past building the software. </p>
<p>&nbsp;<em>Read the next post:</em> <em><a href="http://www.outercurve.org/Blogs/EntryId/131/D-Community-enables-customers">Community enables customers</a></em></p>
