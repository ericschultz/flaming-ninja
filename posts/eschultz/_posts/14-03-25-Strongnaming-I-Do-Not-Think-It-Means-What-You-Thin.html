---
title: "\"Strong-naming\"- I Do Not Think It Means What You Think It Means"
alias: /Blogs/EntryId/143/-Strong-naming-I-Do-Not-Think-It-Means-What-You-Think-It-Means
---
<p><a href="http://msdn.microsoft.com/en-us/library/wd40t7ad%28v=vs.110%29.aspx">Strong-naming</a> is a topic that generates a great deal of conflict in the .Net community. Some developers think it has real advantages. Other developers feel strong-naming is not just useless but actively harmful to creating software. During the last few weeks, I've been researching best practices for strong-naming in open source .Net software. What I've discovered is that there are common misconceptions about the purpose of strong-naming.</p>
<img width="400px;" height="400px;" src="http://i.imgur.com/05DWt3Y.jpg" style="border: medium none; float: right; margin-left: 5px;" alt="Strong-naming - I do not think it means what you think it means" />
<p>As I see it, strong-naming originally had two purposes in .Net. The first is an ability to more intelligently reference libraries. If a developer references a standard assembly, the .Net binder will look for a library with the same name and culture. This is identical to the standard Windows DLL resolution. If a developer references a strong-named assembly however, the .Net binder will also use the referenced version number and strong-name key token for assembly resolution. Additionally, the binder will begin the search for the library in the GAC instead of the local directory. This binding mechanism was created to prevent "<a href="http://en.wikipedia.org/wiki/DLL_Hell">DLL Hell</a>" and allow the system, or even a single piece of software, to have multiple versions of an assemblies with the same names. There&rsquo;s passionate disagreement over whether strong-naming actually was worth the issues with binding redirects but, nonetheless, strong-naming provides a theoretical solution to DLL Hell.</p>
<p>The second purpose of strong-naming was to provide a guarantee that an assembly hadn't been tampered with since it was built. The strong-naming process encrypts a hash of the assembly using the private key of the strong-naming key pair. By decrypting the file hash and verifying that the assembly being referenced is correct, the user can verify whether an assembly has been modified since build time. &nbsp;In many ways, it functions pretty similarly to Authenticode code-signing as an integrity mechanism.</p>
<p>If you're familiar with the .Net framework, you might be nodding along in agreement. Here's the part a lot of .Net developers don't seem to know: the .Net Framework will allow you to load a modified strong-named assembly. It won't warn you; in fact, the signature is (usually) never checked on assembly binding.</p>
<p>If your first thought is that this is a feature of the .Net framework, you're not alone. A quick search <a href="http://stackoverflow.com/questions/12360400/strongname-a-net-assembly-without-access-to-original-keyfile">finds</a> <a href="http://books.google.com/books?id=MwqiLdpq9wYC&amp;pg=PT960&amp;lpg=PT960&amp;dq=strong+naming+integrity&amp;source=bl&amp;ots=iFqo_rwDCu&amp;sig=ft546e_u2LDO3FT6sQIyAIy8bz4&amp;hl=en&amp;sa=X&amp;ei=XUmeUuvfFuKMyQG1lIHIBw&amp;ved=0CEEQ6AEwAzgK#v=onepage&amp;q=strong%20naming%20integrity&amp;f=false">a</a> <a href="http://books.google.com/books?id=kLeaOGyg6K4C&amp;pg=PT597&amp;lpg=PT597&amp;dq=strong+naming+integrity&amp;source=bl&amp;ots=OHAiOezRW_&amp;sig=MG5xi16b89LfiZE3qpiKK2LeGRg&amp;hl=en&amp;sa=X&amp;ei=VEieUvjHH6uyygGtvYFQ&amp;ved=0CFIQ6AEwBQ#v=onepage&amp;q=strong%20naming%20integrity&amp;f=false">number</a> <a href="http://www.dotnet-tv.com/2013/04/22/dot-net-assemblies-and-strong-name-signature/">of</a> <a href="http://www.windowsdevcenter.com/dotnet/2003/04/28/strongnaming.html">people</a> <a href="https://www.owasp.org/index.php/CRV2_FrameworkSpecIssuesASPNetStrongAssembiles">who</a> <a href="http://stackoverflow.com/questions/1254865/do-you-strong-name-all-assemblies-your-product-uses">think</a> <a href="http://stackoverflow.com/questions/9604627/how-to-protect-c-sharp-code-from-modification">that</a> and, to be honest, I thought that too! I wanted to verify this behavior for myself so I created a quick example to illustrate it.</p>
<h1>Example</h1>
<p>I posted my example program to illustrate what strong-naming actually does. The repository for the code is available at <a href="https://github.com/ericschultz/strong-name-signatures-not-checked/">https://github.com/ericschultz/strong-name-signatures-not-checked/</a> so feel free to build it yourself and follow along. The solution consists of three projects:</p>
<ul>
    <li>
    <p><a href="https://github.com/ericschultz/strong-name-signatures-not-checked/tree/master/Test">Test</a> - a simple, strong-named .Net library, with a single method, <a href="https://github.com/ericschultz/strong-name-signatures-not-checked/blob/master/Test/Class1.cs#L11">Test.Class1.TestReturn()</a>, which should return "I'm valid!"</p>
    </li>
    <li>
    <p><a href="https://github.com/ericschultz/strong-name-signatures-not-checked/tree/master/StrongNameVerification">StrongNameVerification</a> - a strong-named .Net command line program that references Test, calls Test.Class1.TestReturn(), and prints the result</p>
    </li>
    <li>
    <p><a href="https://github.com/ericschultz/strong-name-signatures-not-checked/tree/master/HackStrongNamedDll">HackStrongNamedDll</a> - a command line program to modify Test to illustrate the lack of strong-name verification</p>
    </li>
</ul>
<p>To get started, build your solution. Then from a command prompt go to the StrongNameVerification\bin\Debug directory and run StrongNameVerification.exe. The result should look like the command prompt below:</p>
<p><img alt="" src="/Portals/0/images/blog/eric/valid.png" />&nbsp;</p>
<p>Now, without building again, run "../../../HackStrongNamedDll.exe Test.dll" and then run StrongNameVerification.exe again:</p>
<p><img alt="" src="/Portals/0/images/blog/eric/icky.png" />&nbsp;</p>
<p>Uh oh. Our string, which should have been "I'm valid!" is now "I'm icky!!" Of course in this case, the change is unimportant but what if that was a URL or a connection string for a database? Additionally, there's nothing preventing a change in the IL code in the assembly, I simply chose a string to make it easy to modify.</p>
<p>If you're like me, you're probably thinking "but I was POSITIVE the .Net Framework verified the integrity of strong-named assemblies." Well it turns out, that it used to by default but doesn't anymore. Starting in .Net Framework 3.5 SP1, strong-name verification is <a href="http://blogs.msdn.com/b/shawnfa/archive/2008/05/14/strong-name-bypass.aspx">turned off by default</a> for most situations. Startup performance for .Net applications increases substantially if you don't have to verify the hash on every assembly, so the decision was made to make the verification opt-in for the most common situations.</p>
<p>There are still a few situations where strong-name verification is performed by default. The most notable situation is installing an assembly in the GAC. That said, you STILL can't trust that an assembly in the GAC hasn't been tampered with! That's because even though assemblies are verified on installation, they're not verified when loaded from the GAC. If you'd like to prove it for yourself, install a clean version of Test.dll into the GAC, run HackStrongNamedDll.exe with the path into the GAC containing Test.dll and run StrongNameVerification.exe again.</p>
<h1>What to take away</h1>
<p>What I want you to understand is that strong-naming isn't a way to verify integrity of your code. People should debate the positives and negatives of strong-naming. When developers debate though, they should debate based upon what strong-naming <em>actually</em> does versus what developers <em>think</em> strong-naming does. All strong-naming provides is a different mechanism for identifying dependencies; nothing else. Because of that, the debate should revolve solely around whether strong-naming is a good method for identifying assemblies.</p>
